'+cx8' is not a recognized feature for this target (ignoring feature)
'-avx512bf16' is not a recognized feature for this target (ignoring feature)
'-avx512vp2intersect' is not a recognized feature for this target (ignoring feature)
'+cx8' is not a recognized feature for this target (ignoring feature)
'-avx512bf16' is not a recognized feature for this target (ignoring feature)
'-avx512vp2intersect' is not a recognized feature for this target (ignoring feature)
# After Instruction Selection:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Expand ISel Pseudo-instructions:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 Domain Reassignment Pass:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Early Tail Duplication:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Optimize machine instruction PHIs:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Merge disjoint stack slots:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Local Stack Slot Allocation:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Remove dead machine instructions:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Early If-Conversion:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Machine InstCombiner:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 cmov Conversion:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Machine Common Subexpression Elimination:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Machine code sinking:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Peephole Optimizations:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Remove dead machine instructions:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Live Range Shrink:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 Fixup SetCC:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 LEA Optimize:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 Optimize Call Frame:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 speculative load hardening:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 EFLAGS copy lowering:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After X86 WinAlloca Expander:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Detect Dead Lanes:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Process Implicit Definitions:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY $rsi
  %0:gr32 = COPY $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY %10:gr32
  RET 0, $eax

# End machine code for function main.

# After Live Variable Analysis:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY killed $rsi
  %0:gr32 = COPY killed $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm killed %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY killed %10:gr32
  RET 0, killed $eax

# End machine code for function main.

# After Machine Natural Loop Construction:
# Machine code for function main: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY killed $rsi
  %0:gr32 = COPY killed $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm killed %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY killed %10:gr32
  RET 0, killed $eax

# End machine code for function main.

# After Eliminate PHI nodes for register allocation:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY killed $rsi
  %0:gr32 = COPY killed $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm killed %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY killed %10:gr32
  RET 0, killed $eax

# End machine code for function main.

# After Two-Address instruction pass:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

bb.0.entry:
  liveins: $edi, $rsi
  %1:gr64 = COPY killed $rsi
  %0:gr32 = COPY killed $edi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed %0:gr32 :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
  %2:gr64 = MOV64rm killed %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed %3:gr32 :: (store 4 into @symIndex)
  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %5:gr64 = MOV64rm killed %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed %6:gr32 :: (store 4 into @numEntries)
  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  %8:gr64 = MOV64rm killed %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr32 = COPY killed $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed %9:gr32 :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr32 = MOV32r0 implicit-def dead $eflags
  $eax = COPY killed %10:gr32
  RET 0, killed $eax

# End machine code for function main.

# After Simple Register Coalescing:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
80B	  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  $rdi = COPY %2:gr64
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  %3:gr32 = COPY killed $eax
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
192B	  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  %5:gr64 = MOV64rm %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
240B	  $rdi = COPY %5:gr64
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  %6:gr32 = COPY killed $eax
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
320B	  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  %8:gr64 = MOV64rm %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  $rdi = COPY %8:gr64
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  %9:gr32 = COPY killed $eax
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, killed $eax

# End machine code for function main.

# After Rename Disconnected Subregister Components:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
80B	  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  $rdi = COPY %2:gr64
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  %3:gr32 = COPY killed $eax
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
192B	  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  %5:gr64 = MOV64rm %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
240B	  $rdi = COPY %5:gr64
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  %6:gr32 = COPY killed $eax
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
320B	  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  %8:gr64 = MOV64rm %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  $rdi = COPY %8:gr64
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  %9:gr32 = COPY killed $eax
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, killed $eax

# End machine code for function main.

# After Machine Instruction Scheduler:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
80B	  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  $rdi = COPY %2:gr64
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  %3:gr32 = COPY killed $eax
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
192B	  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  %5:gr64 = MOV64rm %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
240B	  $rdi = COPY %5:gr64
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  %6:gr32 = COPY killed $eax
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
320B	  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  %8:gr64 = MOV64rm %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  $rdi = COPY %8:gr64
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  %9:gr32 = COPY killed $eax
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, killed $eax

# End machine code for function main.

# After Greedy Register Allocator:
# Machine code for function main: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi in %0, $rsi in %1

0B	bb.0.entry:
	  liveins: $edi, $rsi
16B	  %1:gr64 = COPY $rsi
32B	  %0:gr32 = COPY $edi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, %0:gr32 :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.argv.addr)
80B	  %2:gr64 = MOV64rm %1:gr64, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  $rdi = COPY %2:gr64
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  %3:gr32 = COPY $eax
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, %3:gr32 :: (store 4 into @symIndex)
192B	  %4:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  %5:gr64 = MOV64rm %4:gr64, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
240B	  $rdi = COPY %5:gr64
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
288B	  %6:gr32 = COPY $eax
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, %6:gr32 :: (store 4 into @numEntries)
320B	  %7:gr64 = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  %8:gr64 = MOV64rm %7:gr64, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  $rdi = COPY %8:gr64
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  %9:gr32 = COPY $eax
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, %9:gr32 :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, $eax

# End machine code for function main.

# After Virtual Register Rewriter:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

0B	bb.0.entry:
	  liveins: $edi, $rsi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
80B	  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
192B	  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
320B	  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, $eax

# End machine code for function main.

# After Stack Slot Coloring:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

0B	bb.0.entry:
	  liveins: $edi, $rsi
48B	  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
64B	  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
80B	  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
96B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
128B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
144B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
192B	  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
208B	  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
224B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
256B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
272B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
320B	  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
336B	  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
352B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
384B	  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
400B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
448B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
480B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  $eax = MOV32r0 implicit-def dead $eflags
528B	  RET 0, $eax

# End machine code for function main.

# After Machine Copy Propagation Pass:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

# End machine code for function main.

# After Machine Loop Invariant Code Motion:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

# End machine code for function main.

# After X86 FP Stackifier:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

# End machine code for function main.

# After PostRA Machine Sink:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

# End machine code for function main.

# After Shrink Wrapping analysis:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  MOV32mr %stack.0.argc.addr, 1, $noreg, 0, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr %stack.1.argv.addr, 1, $noreg, 0, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm %stack.1.argv.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  RET 0, $eax

# End machine code for function main.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0, $eax

# End machine code for function main.

# After Control Flow Optimizer:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0, $eax

# End machine code for function main.

# After Tail Duplication:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0, $eax

# End machine code for function main.

# After Machine Copy Propagation Pass:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = MOV32r0 implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0, $eax

# End machine code for function main.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0, $eax

# End machine code for function main.

# After X86 pseudo instruction expansion pass:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Post RA top-down list latency scheduler:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Branch Probability Basic Block Placement:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Execution Dependency Fix:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After BreakFalseDeps:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Shadow Call Stack:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Indirect Branch Tracking:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 vzeroupper inserter:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Atom pad short functions:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 LEA Fixup:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Discriminate Memory Operands:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Insert Cache Prefetches:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Contiguously Lay Out Funclets:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After StackMap Liveness Analysis:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Live DEBUG_VALUE analysis:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Insert fentry calls:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Insert XRay ops:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Implement the 'patchable-function' attribute:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 Retpoline Thunks:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ $eax

# End machine code for function main.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.5.entry:
; predecessors: %bb.4
  liveins: $rax
  RETQ $eax

# End machine code for function main.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $edi, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.5.entry:
; predecessors: %bb.4
  liveins: $rax
  RETQ $eax

# End machine code for function main.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=4, align=4, at location [SP-20]
  fi#1: size=8, align=8, at location [SP-16]
Function Live Ins: $edi, $rsi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $edi, $rsi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB0_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -12, $noreg, killed renamable $edi :: (store 4 into %ir.argc.addr)
  MOV64mr $rbp, 1, $noreg, -8, $noreg, renamable $rsi :: (store 8 into %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rsi, 1, $noreg, 8, $noreg :: (load 8 from %ir.arrayidx)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax, post-instr-symbol <mcsymbol .LBB0_0_CartridgeEnd>

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV32mr $rip, 1, $noreg, @symIndex, $noreg, killed renamable $eax, pre-instr-symbol <mcsymbol .LBB0_1_CartridgeBody> :: (store 4 into @symIndex)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 16, $noreg :: (load 8 from %ir.arrayidx1)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax, post-instr-symbol <mcsymbol .LBB0_1_CartridgeEnd>

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV32mr $rip, 1, $noreg, @numEntries, $noreg, killed renamable $eax, pre-instr-symbol <mcsymbol .LBB0_2_CartridgeBody> :: (store 4 into @numEntries)
  renamable $rax = MOV64rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 8 from %ir.argv.addr)
  renamable $rdi = MOV64rm killed renamable $rax, 1, $noreg, 24, $noreg :: (load 8 from %ir.arrayidx3)
  CALL64pcrel32 @atoi, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $eax, post-instr-symbol <mcsymbol .LBB0_2_CartridgeEnd>

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV32mr $rip, 1, $noreg, @repetitions, $noreg, killed renamable $eax, pre-instr-symbol <mcsymbol .LBB0_3_CartridgeBody> :: (store 4 into @repetitions)
  CALL64pcrel32 @begin_target_inner, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB0_3_CartridgeEnd>

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rax
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $eax = XOR32rr undef $eax(tied-def 0), undef $eax, implicit-def dead $eflags, pre-instr-symbol <mcsymbol .LBB0_4_CartridgeBody>
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 16, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB0_4_CartridgeEnd>

bb.5.entry:
; predecessors: %bb.4
  liveins: $rax
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB0_5_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB0_5_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ $eax, pre-instr-symbol <mcsymbol .LBB0_5_CartridgeBody>, post-instr-symbol <mcsymbol .LBB0_5_CartridgeEnd>

# End machine code for function main.

# After Instruction Selection:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Expand ISel Pseudo-instructions:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 Domain Reassignment Pass:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Early Tail Duplication:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Optimize machine instruction PHIs:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Merge disjoint stack slots:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Local Stack Slot Allocation:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Remove dead machine instructions:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Early If-Conversion:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine InstCombiner:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 cmov Conversion:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Common Subexpression Elimination:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine code sinking:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Peephole Optimizations:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Remove dead machine instructions:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Live Range Shrink:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 Fixup SetCC:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 LEA Optimize:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 Optimize Call Frame:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 speculative load hardening:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 EFLAGS copy lowering:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 WinAlloca Expander:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Detect Dead Lanes:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Process Implicit Definitions:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Live Variable Analysis:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Natural Loop Construction:
# Machine code for function make_byte_symbolic: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Eliminate PHI nodes for register allocation:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Two-Address instruction pass:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Simple Register Coalescing:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Rename Disconnected Subregister Components:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Instruction Scheduler:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Greedy Register Allocator:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Virtual Register Rewriter:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  liveins: $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Stack Slot Coloring:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  liveins: $rdi
32B	  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
48B	  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Copy Propagation Pass:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Loop Invariant Code Motion:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 FP Stackifier:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After PostRA Machine Sink:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Shrink Wrapping analysis:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  MOV64mr %stack.0.addr.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  RET 0

# End machine code for function make_byte_symbolic.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function make_byte_symbolic.

# After Control Flow Optimizer:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function make_byte_symbolic.

# After Tail Duplication:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function make_byte_symbolic.

# After Machine Copy Propagation Pass:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function make_byte_symbolic.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function make_byte_symbolic.

# After X86 pseudo instruction expansion pass:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Post RA top-down list latency scheduler:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Branch Probability Basic Block Placement:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Execution Dependency Fix:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After BreakFalseDeps:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Shadow Call Stack:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Indirect Branch Tracking:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 vzeroupper inserter:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Atom pad short functions:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 LEA Fixup:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Discriminate Memory Operands:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Insert Cache Prefetches:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Contiguously Lay Out Funclets:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After StackMap Liveness Analysis:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Live DEBUG_VALUE analysis:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Insert fentry calls:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Insert XRay ops:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Implement the 'patchable-function' attribute:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 Retpoline Thunks:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function make_byte_symbolic.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.1.entry:
; predecessors: %bb.0

  RETQ

# End machine code for function make_byte_symbolic.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.1.entry:
; predecessors: %bb.0

  RETQ

# End machine code for function make_byte_symbolic.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function make_byte_symbolic: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-16]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB1_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB1_0_CartridgeHead>
  TASE_JMP_4 &sb_modeled
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB1_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -8, $noreg, killed renamable $rdi :: (store 8 into %ir.addr.addr)
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB1_0_CartridgeEnd>

bb.1.entry:
; predecessors: %bb.0

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB1_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB1_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB1_1_CartridgeBody> post-instr-symbol <mcsymbol .LBB1_1_CartridgeEnd>

# End machine code for function make_byte_symbolic.

# After Instruction Selection:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Expand ISel Pseudo-instructions:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 Domain Reassignment Pass:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Early Tail Duplication:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Optimize machine instruction PHIs:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Merge disjoint stack slots:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Local Stack Slot Allocation:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Remove dead machine instructions:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Early If-Conversion:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Machine InstCombiner:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 cmov Conversion:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Machine Common Subexpression Elimination:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Machine code sinking:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  %6:gr32 = SUB32ri8 %5:gr32(tied-def 0), 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Peephole Optimizations:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Remove dead machine instructions:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Live Range Shrink:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 Fixup SetCC:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 LEA Optimize:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 Optimize Call Frame:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 speculative load hardening:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 EFLAGS copy lowering:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 WinAlloca Expander:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Detect Dead Lanes:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Process Implicit Definitions:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY %8.sub_8bit:gr32
  %10:gr8 = ADD8ri %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Live Variable Analysis:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr killed %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY killed %8.sub_8bit:gr32
  %10:gr8 = ADD8ri killed %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, killed %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 killed %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Machine Natural Loop Construction:
# Machine code for function initializeNums: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr killed %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY killed %8.sub_8bit:gr32
  %10:gr8 = ADD8ri killed %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, killed %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 killed %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Eliminate PHI nodes for register allocation:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = nsw IMUL32rr killed %7:gr32(tied-def 0), %7:gr32, implicit-def dead $eflags
  %9:gr8 = COPY killed %8.sub_8bit:gr32
  %10:gr8 = ADD8ri killed %9:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, killed %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = nsw ADD32ri8 killed %15:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Two-Address instruction pass:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed %4:gr32, %4:gr32, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %13:gr64, 1, killed %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed %5:gr32, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  %7:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  %8:gr32 = COPY killed %7:gr32
  %8:gr32 = nsw IMUL32rr %8:gr32(tied-def 0), %8:gr32, implicit-def dead $eflags
  %9:gr8 = COPY killed %8.sub_8bit:gr32
  %10:gr8 = COPY killed %9:gr8
  %10:gr8 = ADD8ri %10:gr8(tied-def 0), 7, implicit-def dead $eflags
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %10:gr8 :: (store 1 into @garbageCtr)
  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed %11:gr64, 1, killed %12:gr64_nosp, 0, $noreg, killed %10:gr8 :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %15:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %16:gr32 = COPY killed %15:gr32
  %16:gr32 = nsw ADD32ri8 %16:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %16:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Simple Register Coalescing:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi %13:gr64, 1, %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 %5:gr32, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  %8:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  %8:gr32 = nsw IMUL32rr %8:gr32(tied-def 0), %8:gr32, implicit-def dead $eflags
496B	  %8.sub_8bit:gr32 = ADD8ri %8.sub_8bit:gr32(tied-def 0), 7, implicit-def dead $eflags
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %8.sub_8bit:gr32 :: (store 1 into @garbageCtr)
528B	  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr %11:gr64, 1, %12:gr64_nosp, 0, $noreg, %8.sub_8bit:gr32 :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  %16:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  %16:gr32 = nsw ADD32ri8 %16:gr32(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %16:gr32 :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Rename Disconnected Subregister Components:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi %13:gr64, 1, %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 %5:gr32, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  %8:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  %8:gr32 = nsw IMUL32rr %8:gr32(tied-def 0), %8:gr32, implicit-def dead $eflags
496B	  %8.sub_8bit:gr32 = ADD8ri %8.sub_8bit:gr32(tied-def 0), 7, implicit-def dead $eflags
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %8.sub_8bit:gr32 :: (store 1 into @garbageCtr)
528B	  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr %11:gr64, 1, %12:gr64_nosp, 0, $noreg, %8.sub_8bit:gr32 :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  %16:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  %16:gr32 = nsw ADD32ri8 %16:gr32(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %16:gr32 :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Machine Instruction Scheduler:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi %13:gr64, 1, %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 %5:gr32, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  %8:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  %8:gr32 = nsw IMUL32rr %8:gr32(tied-def 0), %8:gr32, implicit-def dead $eflags
496B	  %8.sub_8bit:gr32 = ADD8ri %8.sub_8bit:gr32(tied-def 0), 7, implicit-def dead $eflags
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %8.sub_8bit:gr32 :: (store 1 into @garbageCtr)
528B	  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr %11:gr64, 1, %12:gr64_nosp, 0, $noreg, %8.sub_8bit:gr32 :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  %16:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  %16:gr32 = nsw ADD32ri8 %16:gr32(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %16:gr32 :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Greedy Register Allocator:
# Machine code for function initializeNums: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr %4:gr32, %4:gr32, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  %13:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  %14:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi %13:gr64, 1, %14:gr64_nosp, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  %5:gr32 = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 %5:gr32, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  %8:gr32 = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  %8:gr32 = nsw IMUL32rr %8:gr32(tied-def 0), %8:gr32, implicit-def dead $eflags
496B	  %8.sub_8bit:gr32 = ADD8ri %8.sub_8bit:gr32(tied-def 0), 7, implicit-def dead $eflags
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, %8.sub_8bit:gr32 :: (store 1 into @garbageCtr)
528B	  %11:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  %12:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr %11:gr64, 1, %12:gr64_nosp, 0, $noreg, %8.sub_8bit:gr32 :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  %16:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  %16:gr32 = nsw ADD32ri8 %16:gr32(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %16:gr32 :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Virtual Register Rewriter:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
496B	  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
528B	  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Stack Slot Coloring:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.6
	  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.7, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

176B	  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
192B	  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
208B	  JNE_1 %bb.4, implicit killed $eflags
224B	  JMP_1 %bb.3

240B	bb.3.if.then:
	; predecessors: %bb.2
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

256B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
272B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
288B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
304B	  JMP_1 %bb.6

320B	bb.4.if.else:
	; predecessors: %bb.2
	  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

336B	  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
352B	  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
368B	  JNE_1 %bb.6, implicit killed $eflags
384B	  JMP_1 %bb.5

400B	bb.5.if.then3:
	; predecessors: %bb.4
	  successors: %bb.6(0x80000000); %bb.6(100.00%)

416B	  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
448B	  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
496B	  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
512B	  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
528B	  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
544B	  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
560B	  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

576B	bb.6.if.end8:
	; predecessors: %bb.4, %bb.5, %bb.3
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

592B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
624B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
640B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
656B	  JMP_1 %bb.1

672B	bb.7.for.end:
	; predecessors: %bb.1

688B	  RET 0

# End machine code for function initializeNums.

# After Machine Copy Propagation Pass:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Machine Loop Invariant Code Motion:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After X86 FP Stackifier:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After PostRA Machine Sink:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Shrink Wrapping analysis:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeNums.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.3

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeNums.

# After Control Flow Optimizer:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeNums.

# After Tail Duplication:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeNums.

# After Machine Copy Propagation Pass:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeNums.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeNums.

# After X86 pseudo instruction expansion pass:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Post RA top-down list latency scheduler:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JNE_1 %bb.4, implicit killed $eflags

bb.3.if.then:
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)

bb.6.if.end8:
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Branch Probability Basic Block Placement:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Execution Dependency Fix:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After BreakFalseDeps:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Shadow Call Stack:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Indirect Branch Tracking:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 vzeroupper inserter:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Atom pad short functions:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 LEA Fixup:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Discriminate Memory Operands:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Insert Cache Prefetches:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Contiguously Lay Out Funclets:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After StackMap Liveness Analysis:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Live DEBUG_VALUE analysis:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Insert fentry calls:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Insert XRay ops:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Implement the 'patchable-function' attribute:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 Retpoline Thunks:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.6.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.6
  successors: %bb.2(0x7c000000), %bb.7(0x04000000); %bb.2(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x30000000), %bb.4(0x50000000); %bb.3(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.3, implicit $eflags

bb.4.if.else:
; predecessors: %bb.2
  successors: %bb.5(0x40000000), %bb.6(0x40000000); %bb.5(50.00%), %bb.6(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.6, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.6

bb.3.if.then (align 4):
; predecessors: %bb.2
  successors: %bb.6(0x80000000); %bb.6(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.6

bb.7.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeNums.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.6
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.3.for.body:
; predecessors: %bb.2
  successors: %bb.6(0x30000000), %bb.4(0x50000000); %bb.6(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.6, implicit $eflags

bb.4.if.else:
; predecessors: %bb.3
  successors: %bb.5(0x40000000), %bb.1(0x40000000); %bb.5(50.00%), %bb.1(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.1, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.1

bb.6.if.then (align 4):
; predecessors: %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.2
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.8.for.end:
; predecessors: %bb.7

  RETQ

# End machine code for function initializeNums.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.6
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags

bb.3.for.body:
; predecessors: %bb.2
  successors: %bb.6(0x30000000), %bb.4(0x50000000); %bb.6(37.50%), %bb.4(62.50%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.6, implicit $eflags

bb.4.if.else:
; predecessors: %bb.3
  successors: %bb.5(0x40000000), %bb.1(0x40000000); %bb.5(50.00%), %bb.1(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.1, implicit $eflags

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.1

bb.6.if.then (align 4):
; predecessors: %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.1

bb.7.for.end:
; predecessors: %bb.2
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.8.for.end:
; predecessors: %bb.7

  RETQ

# End machine code for function initializeNums.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function initializeNums: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB2_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2, post-instr-symbol <mcsymbol .LBB2_0_CartridgeEnd>

bb.1.if.end8 (align 4):
; predecessors: %bb.4, %bb.5, %bb.6
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB2_1_CartridgeBody> :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax, post-instr-symbol <mcsymbol .LBB2_1_CartridgeEnd> :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.3(0x7c000000), %bb.7(0x04000000); %bb.3(96.88%), %bb.7(3.12%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB2_2_CartridgeBody> :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.7, implicit killed $eflags, post-instr-symbol <mcsymbol .LBB2_2_CartridgeEnd>

bb.3.for.body:
; predecessors: %bb.2
  successors: %bb.6(0x30000000), %bb.4(0x50000000); %bb.6(37.50%), %bb.4(62.50%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg, pre-instr-symbol <mcsymbol .LBB2_3_CartridgeBody> :: (dereferenceable load 4 from @testType)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JE_1 %bb.6, implicit $eflags, post-instr-symbol <mcsymbol .LBB2_3_CartridgeEnd>

bb.4.if.else:
; predecessors: %bb.3
  successors: %bb.5(0x40000000), %bb.1(0x40000000); %bb.5(50.00%), %bb.1(50.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rip, 1, $noreg, @testType, $noreg, pre-instr-symbol <mcsymbol .LBB2_4_CartridgeBody> :: (dereferenceable load 4 from @testType)
  CMP32ri8 killed renamable $eax, 1, implicit-def $eflags
  JNE_1 %bb.1, implicit $eflags, post-instr-symbol <mcsymbol .LBB2_4_CartridgeEnd>

bb.5.if.then3:
; predecessors: %bb.4
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_5_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_5_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOVZX32rm8 $rip, 1, $noreg, @garbageCtr, $noreg, pre-instr-symbol <mcsymbol .LBB2_5_CartridgeBody> :: (dereferenceable load 1 from @garbageCtr)
  renamable $eax = nsw IMUL32rr killed renamable $eax(tied-def 0), renamable $eax, implicit-def dead $eflags
  renamable $al = ADD8ri renamable $al(tied-def 0), 7, implicit-def dead $eflags, implicit killed $eax, implicit-def $eax
  MOV8mr $rip, 1, $noreg, @garbageCtr, $noreg, renamable $al :: (store 1 into @garbageCtr)
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rdx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx7)
  JMP_1 %bb.1, post-instr-symbol <mcsymbol .LBB2_5_CartridgeEnd>

bb.6.if.then (align 4):
; predecessors: %bb.3
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_6_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_6_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB2_6_CartridgeBody> :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 1 :: (store 1 into %ir.arrayidx)
  JMP_1 %bb.1, post-instr-symbol <mcsymbol .LBB2_6_CartridgeEnd>

bb.7.for.end:
; predecessors: %bb.2
  successors: %bb.8(0x80000000); %bb.8(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_7_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_7_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB2_7_CartridgeBody>
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB2_7_CartridgeEnd>

bb.8.for.end:
; predecessors: %bb.7

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB2_8_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB2_8_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB2_8_CartridgeBody> post-instr-symbol <mcsymbol .LBB2_8_CartridgeEnd>

# End machine code for function initializeNums.

# After Instruction Selection:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Expand ISel Pseudo-instructions:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 Domain Reassignment Pass:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Early Tail Duplication:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Optimize machine instruction PHIs:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Merge disjoint stack slots:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Local Stack Slot Allocation:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Remove dead machine instructions:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Early If-Conversion:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Machine InstCombiner:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 cmov Conversion:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Machine Common Subexpression Elimination:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Machine code sinking:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Peephole Optimizations:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Remove dead machine instructions:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Live Range Shrink:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 Fixup SetCC:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 LEA Optimize:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 Optimize Call Frame:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 speculative load hardening:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 EFLAGS copy lowering:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 WinAlloca Expander:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Detect Dead Lanes:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Process Implicit Definitions:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Live Variable Analysis:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Machine Natural Loop Construction:
# Machine code for function initializeAllOnes: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Eliminate PHI nodes for register allocation:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Two-Address instruction pass:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = COPY killed %6:gr32
  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Simple Register Coalescing:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Rename Disconnected Subregister Components:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Machine Instruction Scheduler:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Greedy Register Allocator:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Virtual Register Rewriter:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Stack Slot Coloring:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllOnes.

# After Machine Copy Propagation Pass:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Machine Loop Invariant Code Motion:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After X86 FP Stackifier:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After PostRA Machine Sink:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Shrink Wrapping analysis:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllOnes.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllOnes.

# After Control Flow Optimizer:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllOnes.

# After Tail Duplication:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllOnes.

# After Machine Copy Propagation Pass:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllOnes.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllOnes.

# After X86 pseudo instruction expansion pass:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Post RA top-down list latency scheduler:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Branch Probability Basic Block Placement:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Execution Dependency Fix:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After BreakFalseDeps:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Shadow Call Stack:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Indirect Branch Tracking:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 vzeroupper inserter:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Atom pad short functions:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 LEA Fixup:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Discriminate Memory Operands:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Insert Cache Prefetches:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Contiguously Lay Out Funclets:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After StackMap Liveness Analysis:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Live DEBUG_VALUE analysis:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Insert fentry calls:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Insert XRay ops:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Implement the 'patchable-function' attribute:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 Retpoline Thunks:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllOnes.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function initializeAllOnes.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function initializeAllOnes.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function initializeAllOnes: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB3_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB3_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB3_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2, post-instr-symbol <mcsymbol .LBB3_0_CartridgeEnd>

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB3_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB3_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB3_1_CartridgeBody> :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, -1 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax, post-instr-symbol <mcsymbol .LBB3_1_CartridgeEnd> :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB3_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB3_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB3_2_CartridgeBody> :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags, post-instr-symbol <mcsymbol .LBB3_2_CartridgeEnd>

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB3_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB3_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB3_3_CartridgeBody>
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB3_3_CartridgeEnd>

bb.4.for.end:
; predecessors: %bb.3

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB3_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB3_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB3_4_CartridgeBody> post-instr-symbol <mcsymbol .LBB3_4_CartridgeEnd>

# End machine code for function initializeAllOnes.

# After Instruction Selection:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Expand ISel Pseudo-instructions:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 Domain Reassignment Pass:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Early Tail Duplication:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Optimize machine instruction PHIs:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Merge disjoint stack slots:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Local Stack Slot Allocation:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Remove dead machine instructions:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Early If-Conversion:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Machine InstCombiner:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 cmov Conversion:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Machine Common Subexpression Elimination:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Machine code sinking:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %3:gr32 = SUB32rr %1:gr32(tied-def 0), killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Peephole Optimizations:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Remove dead machine instructions:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Live Range Shrink:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 Fixup SetCC:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 LEA Optimize:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 Optimize Call Frame:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 speculative load hardening:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 EFLAGS copy lowering:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 WinAlloca Expander:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Detect Dead Lanes:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Process Implicit Definitions:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Live Variable Analysis:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Machine Natural Loop Construction:
# Machine code for function initializeAllZeros: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Eliminate PHI nodes for register allocation:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = nsw ADD32ri8 killed %6:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Two-Address instruction pass:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %1:gr32, killed %2:gr32, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed %4:gr64, 1, killed %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %6:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %7:gr32 = COPY killed %6:gr32
  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed %7:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Simple Register Coalescing:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Rename Disconnected Subregister Components:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Machine Instruction Scheduler:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Greedy Register Allocator:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi in %0

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
16B	  %0:gr64 = COPY $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  %1:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  %2:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr %1:gr32, %2:gr32, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  %4:gr64 = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  %5:gr64_nosp = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi %4:gr64, 1, %5:gr64_nosp, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  %7:gr32 = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  %7:gr32 = nsw ADD32ri8 %7:gr32(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, %7:gr32 :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Virtual Register Rewriter:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Stack Slot Coloring:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi
32B	  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
48B	  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

64B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.3
	  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

80B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
96B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
112B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
128B	  JGE_1 %bb.4, implicit killed $eflags
144B	  JMP_1 %bb.2

160B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

176B	  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
192B	  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
208B	  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

224B	bb.3.for.inc:
	; predecessors: %bb.2
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

240B	  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
272B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
288B	  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
304B	  JMP_1 %bb.1

320B	bb.4.for.end:
	; predecessors: %bb.1

336B	  RET 0

# End machine code for function initializeAllZeros.

# After Machine Copy Propagation Pass:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Machine Loop Invariant Code Motion:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After X86 FP Stackifier:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After PostRA Machine Sink:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Shrink Wrapping analysis:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  MOV64mr %stack.0.numArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi %stack.1.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.numArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm %stack.1.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.1.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  RET 0

# End machine code for function initializeAllZeros.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.3
  successors: %bb.2(0x7c000000), %bb.4(0x04000000); %bb.2(96.88%), %bb.4(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.4, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)

bb.3.for.inc:
; predecessors: %bb.2
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.4.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllZeros.

# After Control Flow Optimizer:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllZeros.

# After Tail Duplication:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllZeros.

# After Machine Copy Propagation Pass:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllZeros.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function initializeAllZeros.

# After X86 pseudo instruction expansion pass:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Post RA top-down list latency scheduler:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Branch Probability Basic Block Placement:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Execution Dependency Fix:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After BreakFalseDeps:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Shadow Call Stack:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Indirect Branch Tracking:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 vzeroupper inserter:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Atom pad short functions:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 LEA Fixup:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Discriminate Memory Operands:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Insert Cache Prefetches:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Contiguously Lay Out Funclets:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After StackMap Liveness Analysis:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Live DEBUG_VALUE analysis:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Insert fentry calls:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Insert XRay ops:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Implement the 'patchable-function' attribute:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 Retpoline Thunks:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function initializeAllZeros.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function initializeAllZeros.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function initializeAllZeros.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function initializeAllZeros: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=4, align=4, at location [SP-12]
Function Live Ins: $rdi

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB4_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB4_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB4_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rdi :: (store 8 into %ir.numArray.addr)
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2, post-instr-symbol <mcsymbol .LBB4_0_CartridgeEnd>

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB4_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB4_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB4_1_CartridgeBody> :: (dereferenceable load 8 from %ir.numArray.addr)
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  MOV8mi killed renamable $rax, 1, killed renamable $rcx, 0, $noreg, 0 :: (store 1 into %ir.arrayidx)
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax, post-instr-symbol <mcsymbol .LBB4_1_CartridgeEnd> :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB4_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB4_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB4_2_CartridgeBody> :: (dereferenceable load 4 from %ir.i)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags, post-instr-symbol <mcsymbol .LBB4_2_CartridgeEnd>

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB4_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB4_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB4_3_CartridgeBody>
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB4_3_CartridgeEnd>

bb.4.for.end:
; predecessors: %bb.3

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB4_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB4_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB4_4_CartridgeBody> post-instr-symbol <mcsymbol .LBB4_4_CartridgeEnd>

# End machine code for function initializeAllZeros.

# After Instruction Selection:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Expand ISel Pseudo-instructions:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 Domain Reassignment Pass:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Early Tail Duplication:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Optimize machine instruction PHIs:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Merge disjoint stack slots:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Local Stack Slot Allocation:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Remove dead machine instructions:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Early If-Conversion:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Machine InstCombiner:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 cmov Conversion:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Machine Common Subexpression Elimination:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Machine code sinking:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %14:gr32 = SUB32rr %12:gr32(tied-def 0), killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  %20:gr32 = SUB32rr %18:gr32(tied-def 0), killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Peephole Optimizations:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Remove dead machine instructions:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Live Range Shrink:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 Fixup SetCC:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 LEA Optimize:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 Optimize Call Frame:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 speculative load hardening:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 EFLAGS copy lowering:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 WinAlloca Expander:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Detect Dead Lanes:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Process Implicit Definitions:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY %21:gr64  ==> insn has taint
  $rsi = COPY %22:gr64  ==> insn has taint
  $rdx = COPY %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Live Variable Analysis:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY killed $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY killed $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 killed %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY killed $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr killed %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %21:gr64  ==> insn has taint
  $rsi = COPY killed %22:gr64  ==> insn has taint
  $rdx = COPY killed %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 killed %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Machine Natural Loop Construction:
# Machine code for function begin_target_inner: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY killed $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY killed $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 killed %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY killed $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr killed %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %21:gr64  ==> insn has taint
  $rsi = COPY killed %22:gr64  ==> insn has taint
  $rdx = COPY killed %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 killed %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Eliminate PHI nodes for register allocation:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY killed $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY killed $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = nsw ADD64ri8 killed %4:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY killed $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = ADD64rr killed %15:gr64(tied-def 0), killed %16:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %21:gr64  ==> insn has taint
  $rsi = COPY killed %22:gr64  ==> insn has taint
  $rdx = COPY killed %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = nsw ADD32ri8 killed %24:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Two-Address instruction pass:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %0:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %1:gr64 = COPY killed $rax
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.firstArray)
  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %2:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %3:gr64 = COPY killed $rax
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed %3:gr64 :: (store 8 into %ir.secondArray)
  %4:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr64 = COPY killed %4:gr64
  %5:gr64 = nsw ADD64ri8 %5:gr64(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %5:gr64
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %6:gr64 = COPY killed $rax
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed %6:gr64 :: (store 8 into %ir.resultArray)
  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %7:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %8:gr64
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %9:gr64
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  $rdi = COPY killed %10:gr64
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed %11:gr32, %11:gr32, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %12:gr32, killed %13:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  %16:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  %17:gr64 = COPY killed %16:gr64
  %17:gr64 = ADD64rr %17:gr64(tied-def 0), killed %15:gr64, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %17:gr64  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed %18:gr32, killed %19:gr32, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  $rdi = COPY killed %21:gr64  ==> insn has taint
  $rsi = COPY killed %22:gr64  ==> insn has taint
  $rdx = COPY killed %23:gr64  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  %24:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %25:gr32 = COPY killed %24:gr32
  %25:gr32 = nsw ADD32ri8 %25:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %25:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Simple Register Coalescing:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = COPY killed $rax
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
128B	  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $rdi = COPY %2:gr64
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %3:gr64 = COPY killed $rax
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
240B	  %5:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  %5:gr64 = nsw ADD64ri8 %5:gr64(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  $rdi = COPY %5:gr64
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  %6:gr64 = COPY killed $rax
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
384B	  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  $rdi = COPY %7:gr64
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  $rdi = COPY %8:gr64
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $rdi = COPY %9:gr64
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
656B	  $rdi = COPY %10:gr64
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr %12:gr32, %13:gr32, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  %17:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  %17:gr64 = ADD64rr %17:gr64(tied-def 0), %15:gr64, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
976B	  $rdi = COPY %17:gr64  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr %18:gr32, %19:gr32, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
1200B	  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1232B	  $rdi = COPY %21:gr64  ==> insn has taint
1248B	  $rsi = COPY %22:gr64  ==> insn has taint
1264B	  $rdx = COPY %23:gr64  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  %25:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  %25:gr32 = nsw ADD32ri8 %25:gr32(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %25:gr32 :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Rename Disconnected Subregister Components:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = COPY killed $rax
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
128B	  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $rdi = COPY %2:gr64
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %3:gr64 = COPY killed $rax
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
240B	  %5:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  %5:gr64 = nsw ADD64ri8 %5:gr64(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  $rdi = COPY %5:gr64
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  %6:gr64 = COPY killed $rax
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
384B	  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  $rdi = COPY %7:gr64
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  $rdi = COPY %8:gr64
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $rdi = COPY %9:gr64
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
656B	  $rdi = COPY %10:gr64
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr %12:gr32, %13:gr32, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  %17:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  %17:gr64 = ADD64rr %17:gr64(tied-def 0), %15:gr64, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
976B	  $rdi = COPY %17:gr64  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr %18:gr32, %19:gr32, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
1200B	  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1232B	  $rdi = COPY %21:gr64  ==> insn has taint
1248B	  $rsi = COPY %22:gr64  ==> insn has taint
1264B	  $rdx = COPY %23:gr64  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  %25:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  %25:gr32 = nsw ADD32ri8 %25:gr32(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %25:gr32 :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Machine Instruction Scheduler:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = COPY killed $rax
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
128B	  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $rdi = COPY %2:gr64
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %3:gr64 = COPY killed $rax
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
240B	  %5:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  %5:gr64 = nsw ADD64ri8 %5:gr64(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  $rdi = COPY %5:gr64
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  %6:gr64 = COPY killed $rax
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
384B	  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  $rdi = COPY %7:gr64
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  $rdi = COPY %8:gr64
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $rdi = COPY %9:gr64
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
656B	  $rdi = COPY %10:gr64
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr %12:gr32, %13:gr32, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  %17:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  %17:gr64 = ADD64rr %17:gr64(tied-def 0), %15:gr64, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
976B	  $rdi = COPY %17:gr64  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr %18:gr32, %19:gr32, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
1200B	  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1232B	  $rdi = COPY %21:gr64  ==> insn has taint
1248B	  $rsi = COPY %22:gr64  ==> insn has taint
1264B	  $rdx = COPY %23:gr64  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit killed $rdi, implicit killed $rsi, implicit killed $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  %25:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  %25:gr32 = nsw ADD32ri8 %25:gr32(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %25:gr32 :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Greedy Register Allocator:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  %0:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
48B	  $rdi = COPY %0:gr64
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
96B	  %1:gr64 = COPY $rax
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.firstArray)
128B	  %2:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
160B	  $rdi = COPY %2:gr64
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
208B	  %3:gr64 = COPY $rax
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, %3:gr64 :: (store 8 into %ir.secondArray)
240B	  %5:gr64 = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  %5:gr64 = nsw ADD64ri8 %5:gr64(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
304B	  $rdi = COPY %5:gr64
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
352B	  %6:gr64 = COPY $rax
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, %6:gr64 :: (store 8 into %ir.resultArray)
384B	  %7:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
416B	  $rdi = COPY %7:gr64
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  %8:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
496B	  $rdi = COPY %8:gr64
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  %9:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
576B	  $rdi = COPY %9:gr64
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  %10:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
656B	  $rdi = COPY %10:gr64
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  %11:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr %11:gr32, %11:gr32, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  %12:gr32 = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  %13:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr %12:gr32, %13:gr32, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  %15:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  %17:gr64 = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  %17:gr64 = ADD64rr %17:gr64(tied-def 0), %15:gr64, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, %17:gr64 :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
976B	  $rdi = COPY %17:gr64  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  %18:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  %19:gr32 = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr %18:gr32, %19:gr32, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  %21:gr64 = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  %22:gr64 = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
1200B	  %23:gr64 = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1232B	  $rdi = COPY %21:gr64  ==> insn has taint
1248B	  $rsi = COPY %22:gr64  ==> insn has taint
1264B	  $rdx = COPY %23:gr64  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  %25:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  %25:gr32 = nsw ADD32ri8 %25:gr32(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %25:gr32 :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Virtual Register Rewriter:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
128B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
240B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
384B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
1200B	  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Stack Slot Coloring:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

0B	bb.0.entry:
	  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

16B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
32B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
64B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
80B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
112B	  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
128B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
144B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
176B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
192B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
224B	  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
240B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
272B	  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
288B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
320B	  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
336B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
368B	  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
384B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
400B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
432B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
448B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
464B	  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
480B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
512B	  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
528B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
544B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
560B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
592B	  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
608B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
624B	  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
640B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
672B	  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
688B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
704B	  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
720B	  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
736B	  JS_1 %bb.3, implicit killed $eflags
752B	  JMP_1 %bb.1

768B	bb.1.land.lhs.true:
	; predecessors: %bb.0
	  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

784B	  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
800B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
816B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
832B	  JGE_1 %bb.3, implicit killed $eflags
848B	  JMP_1 %bb.2

864B	bb.2.if.then:
	; predecessors: %bb.1
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

880B	  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
896B	  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
928B	  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
944B	  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
960B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
992B	  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1008B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

1024B	bb.3.if.end:
	; predecessors: %bb.0, %bb.1, %bb.2
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1040B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

1056B	bb.4.for.cond:
	; predecessors: %bb.3, %bb.5
	  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

1072B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
1088B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
1104B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
1120B	  JGE_1 %bb.6, implicit killed $eflags
1136B	  JMP_1 %bb.5

1152B	bb.5.for.body:
	; predecessors: %bb.4
	  successors: %bb.4(0x80000000); %bb.4(100.00%)

1168B	  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
1184B	  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
1200B	  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
1216B	  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1280B	  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
1296B	  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
1312B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
1344B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
1360B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
1376B	  JMP_1 %bb.4

1392B	bb.6.for.end:
	; predecessors: %bb.4

1408B	  RET 0

# End machine code for function begin_target_inner.

# After Machine Copy Propagation Pass:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Machine Loop Invariant Code Motion:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After X86 FP Stackifier:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After PostRA Machine Sink:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Shrink Wrapping analysis:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=8, align=8, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.0.firstArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.1.secondArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  MOV64mr %stack.2.resultArray, 1, $noreg, 0, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $rdi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr %stack.3.symAddr, 1, $noreg, 0, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm %stack.0.firstArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm %stack.1.secondArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  RET 0

# End machine code for function begin_target_inner.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.1

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags
  JMP_1 %bb.5

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function begin_target_inner.

# After Control Flow Optimizer:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function begin_target_inner.

# After Tail Duplication:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function begin_target_inner.

# After Machine Copy Propagation Pass:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function begin_target_inner.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function begin_target_inner.

# After X86 pseudo instruction expansion pass:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Post RA top-down list latency scheduler:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.6, implicit killed $eflags

bb.5.for.body:
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.4

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Branch Probability Basic Block Placement:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Execution Dependency Fix:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After BreakFalseDeps:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Shadow Call Stack:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Indirect Branch Tracking:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 vzeroupper inserter:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Atom pad short functions:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 LEA Fixup:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Discriminate Memory Operands:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Insert Cache Prefetches:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Contiguously Lay Out Funclets:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After StackMap Liveness Analysis:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Live DEBUG_VALUE analysis:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Insert fentry calls:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Insert XRay ops:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Implement the 'patchable-function' attribute:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 Retpoline Thunks:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x40000000), %bb.3(0x40000000); %bb.1(50.00%), %bb.3(50.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.3, implicit $eflags

bb.1.land.lhs.true:
; predecessors: %bb.0
  successors: %bb.2(0x40000000), %bb.3(0x40000000); %bb.2(50.00%), %bb.3(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags

bb.2.if.then:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.3.if.end:
; predecessors: %bb.0, %bb.1, %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.4

bb.5.for.body (align 4):
; predecessors: %bb.4
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.4.for.cond:
; predecessors: %bb.3, %bb.5
  successors: %bb.5(0x7c000000), %bb.6(0x04000000); %bb.5(96.88%), %bb.6(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.5, implicit $eflags

bb.6.for.end:
; predecessors: %bb.4

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function begin_target_inner.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.5.entry:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.6.entry:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.7.entry:
; predecessors: %bb.6
  successors: %bb.8(0x40000000), %bb.10(0x40000000); %bb.8(50.00%), %bb.10(50.00%)
  liveins: $rax
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.10, implicit $eflags

bb.8.land.lhs.true:
; predecessors: %bb.7
  successors: %bb.9(0x40000000), %bb.10(0x40000000); %bb.9(50.00%), %bb.10(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.10, implicit $eflags

bb.9.if.then:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.10.if.end:
; predecessors: %bb.8, %bb.9, %bb.7
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.13

bb.11.for.body (align 4):
; predecessors: %bb.13
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.12.for.body:
; predecessors: %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)
  liveins: $rax, $rbp
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.13.for.cond:
; predecessors: %bb.10, %bb.12
  successors: %bb.11(0x7c000000), %bb.14(0x04000000); %bb.11(96.88%), %bb.14(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.11, implicit $eflags

bb.14.for.end:
; predecessors: %bb.13
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.15.for.end:
; predecessors: %bb.14

  RETQ

# End machine code for function begin_target_inner.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax, $rbp
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.5.entry:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.6.entry:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)
  liveins: $rbp
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp

bb.7.entry:
; predecessors: %bb.6
  successors: %bb.8(0x40000000), %bb.10(0x40000000); %bb.8(50.00%), %bb.10(50.00%)
  liveins: $rax
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.10, implicit $eflags

bb.8.land.lhs.true:
; predecessors: %bb.7
  successors: %bb.9(0x40000000), %bb.10(0x40000000); %bb.9(50.00%), %bb.10(50.00%)

  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.10, implicit $eflags

bb.9.if.then:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  $xmm15 = PINSRQrm $xmm15(tied-def 0), $rsp, 1, $noreg, -8, $noreg, 0
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.10.if.end:
; predecessors: %bb.8, %bb.9, %bb.7
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  $r14 = LEA64r $rbp, 1, $noreg, -4, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.13

bb.11.for.body (align 4):
; predecessors: %bb.13
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  $r14 = LEA64r $rbp, 1, $noreg, -16, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -32, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  $xmm15 = PINSRQrm $xmm15(tied-def 0), $rsp, 1, $noreg, -8, $noreg, 0
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp  ==> insn has taint

bb.12.for.body:
; predecessors: %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)
  liveins: $rax, $rbp
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.13.for.cond:
; predecessors: %bb.10, %bb.12
  successors: %bb.11(0x7c000000), %bb.14(0x04000000); %bb.11(96.88%), %bb.14(3.12%)

  $r14 = LEA64r $rbp, 1, $noreg, -4, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.11, implicit $eflags

bb.14.for.end:
; predecessors: %bb.13
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.15.for.end:
; predecessors: %bb.14

  RETQ

# End machine code for function begin_target_inner.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function begin_target_inner: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-24]
  fi#1: size=8, align=8, at location [SP-32]
  fi#2: size=8, align=8, at location [SP-40]
  fi#3: size=8, align=8, at location [SP-48]
  fi#4: size=4, align=4, at location [SP-12]

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB5_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $rsp = frame-setup SUB64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax, post-instr-symbol <mcsymbol .LBB5_0_CartridgeEnd>

bb.1.entry:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV64mr $rbp, 1, $noreg, -16, $noreg, killed renamable $rax, pre-instr-symbol <mcsymbol .LBB5_1_CartridgeBody> :: (store 8 into %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax, post-instr-symbol <mcsymbol .LBB5_1_CartridgeEnd>

bb.2.entry:
; predecessors: %bb.1
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV64mr $rbp, 1, $noreg, -24, $noreg, killed renamable $rax, pre-instr-symbol <mcsymbol .LBB5_2_CartridgeBody> :: (store 8 into %ir.secondArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  renamable $rdi = nsw ADD64ri8 killed renamable $rdi(tied-def 0), 1, implicit-def dead $eflags
  CALL64pcrel32 @malloc, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, implicit-def $rax, post-instr-symbol <mcsymbol .LBB5_2_CartridgeEnd>

bb.3.entry:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rax, pre-instr-symbol <mcsymbol .LBB5_3_CartridgeBody> :: (store 8 into %ir.resultArray)
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_3_CartridgeEnd>

bb.4.entry:
; predecessors: %bb.3
  successors: %bb.5(0x80000000); %bb.5(100.00%)
  liveins: $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg, pre-instr-symbol <mcsymbol .LBB5_4_CartridgeBody> :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeNums, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_4_CartridgeEnd>

bb.5.entry:
; predecessors: %bb.4
  successors: %bb.6(0x80000000); %bb.6(100.00%)
  liveins: $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_5_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_5_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB5_5_CartridgeBody> :: (dereferenceable load 8 from %ir.firstArray)
  CALL64pcrel32 @initializeAllZeros, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_5_CartridgeEnd>

bb.6.entry:
; predecessors: %bb.5
  successors: %bb.7(0x80000000); %bb.7(100.00%)
  liveins: $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_6_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_6_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -24, $noreg, pre-instr-symbol <mcsymbol .LBB5_6_CartridgeBody> :: (dereferenceable load 8 from %ir.secondArray)
  CALL64pcrel32 @initializeAllOnes, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_6_CartridgeEnd>

bb.7.entry:
; predecessors: %bb.6
  successors: %bb.8(0x40000000), %bb.10(0x40000000); %bb.8(50.00%), %bb.10(50.00%)
  liveins: $rax
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_7_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_7_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg, pre-instr-symbol <mcsymbol .LBB5_7_CartridgeBody> :: (dereferenceable load 4 from @symIndex)
  TEST32rr killed renamable $eax, renamable $eax, implicit-def $eflags
  JS_1 %bb.10, implicit $eflags, post-instr-symbol <mcsymbol .LBB5_7_CartridgeEnd>

bb.8.land.lhs.true:
; predecessors: %bb.7
  successors: %bb.9(0x40000000), %bb.10(0x40000000); %bb.9(50.00%), %bb.10(50.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_8_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_8_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rip, 1, $noreg, @symIndex, $noreg, pre-instr-symbol <mcsymbol .LBB5_8_CartridgeBody> :: (dereferenceable load 4 from @symIndex)
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.10, implicit $eflags, post-instr-symbol <mcsymbol .LBB5_8_CartridgeEnd>

bb.9.if.then:
; predecessors: %bb.8
  successors: %bb.10(0x80000000); %bb.10(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_9_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_9_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $rax = MOV64rm $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB5_9_CartridgeBody> :: (dereferenceable load 8 from %ir.firstArray)
  renamable $rdi = MOVSX64rm32 $rip, 1, $noreg, @symIndex, $noreg :: (dereferenceable load 4 from @symIndex)
  renamable $rdi = ADD64rr killed renamable $rdi(tied-def 0), killed renamable $rax, implicit-def dead $eflags
  MOV64mr $rbp, 1, $noreg, -40, $noreg, renamable $rdi :: (store 8 into %ir.symAddr)
  $xmm15 = PINSRQrm $xmm15(tied-def 0), $rsp, 1, $noreg, -8, $noreg, 0
  CALL64pcrel32 @make_byte_symbolic, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_9_CartridgeEnd>  ==> insn has taint

bb.10.if.end:
; predecessors: %bb.8, %bb.9, %bb.7
  successors: %bb.13(0x80000000); %bb.13(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_10_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_10_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB5_10_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  MOV32mi $rbp, 1, $noreg, -4, $noreg, 0 :: (store 4 into %ir.i)  ==> insn has taint
  JMP_1 %bb.13, post-instr-symbol <mcsymbol .LBB5_10_CartridgeEnd>

bb.11.for.body (align 4):
; predecessors: %bb.13
  successors: %bb.12(0x80000000); %bb.12(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_11_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_11_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -16, $noreg, pre-instr-symbol <mcsymbol .LBB5_11_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdi = MOV64rm $rbp, 1, $noreg, -16, $noreg :: (dereferenceable load 8 from %ir.firstArray)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rsi = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.secondArray)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -32, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.resultArray)  ==> insn has taint
  $xmm15 = PINSRQrm $xmm15(tied-def 0), $rsp, 1, $noreg, -8, $noreg, 0
  CALL64pcrel32 @runTest, <regmask $bh $bl $bp $bph $bpl $bx $ebp $ebx $hbp $hbx $rbp $rbx $r12 $r13 $r14 $r15 $r12b $r13b $r14b $r15b $r12bh $r13bh $r14bh $r15bh $r12d $r13d $r14d $r15d $r12w $r13w $r14w $r15w $r12wh and 3 more...>, implicit $rsp, implicit $ssp, implicit $rdi, implicit $rsi, implicit $rdx, implicit-def $rsp, implicit-def $ssp, post-instr-symbol <mcsymbol .LBB5_11_CartridgeEnd>  ==> insn has taint

bb.12.for.body:
; predecessors: %bb.11
  successors: %bb.13(0x80000000); %bb.13(100.00%)
  liveins: $rax, $rbp
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_12_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_12_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB5_12_CartridgeBody> :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -4, $noreg, killed renamable $eax, post-instr-symbol <mcsymbol .LBB5_12_CartridgeEnd> :: (store 4 into %ir.i)

bb.13.for.cond:
; predecessors: %bb.10, %bb.12
  successors: %bb.11(0x7c000000), %bb.14(0x04000000); %bb.11(96.88%), %bb.14(3.12%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_13_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_13_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -4, $noreg, pre-instr-symbol <mcsymbol .LBB5_13_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $eax = MOV32rm $rbp, 1, $noreg, -4, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @repetitions, $noreg :: (dereferenceable load 4 from @repetitions)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.11, implicit $eflags, post-instr-symbol <mcsymbol .LBB5_13_CartridgeEnd>

bb.14.for.end:
; predecessors: %bb.13
  successors: %bb.15(0x80000000); %bb.15(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_14_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_14_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $rsp = frame-destroy ADD64ri8 $rsp(tied-def 0), 48, implicit-def dead $eflags, pre-instr-symbol <mcsymbol .LBB5_14_CartridgeBody>
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB5_14_CartridgeEnd>

bb.15.for.end:
; predecessors: %bb.14

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB5_15_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB5_15_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB5_15_CartridgeBody> post-instr-symbol <mcsymbol .LBB5_15_CartridgeEnd>

# End machine code for function begin_target_inner.

# After Instruction Selection:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Expand ISel Pseudo-instructions:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 Domain Reassignment Pass:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Early Tail Duplication:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Optimize machine instruction PHIs:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Merge disjoint stack slots:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Local Stack Slot Allocation:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Remove dead machine instructions:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Early If-Conversion:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Machine InstCombiner:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 cmov Conversion:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Early Machine Loop Invariant Code Motion:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Machine Common Subexpression Elimination:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Machine code sinking:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  %5:gr32 = SUB32rr %3:gr32(tied-def 0), killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Peephole Optimizations:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Remove dead machine instructions:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Live Range Shrink:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 Fixup SetCC:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 LEA Optimize:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 Optimize Call Frame:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 Avoid Store Forwarding Blocks:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 speculative load hardening:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 EFLAGS copy lowering:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 WinAlloca Expander:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Detect Dead Lanes:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Process Implicit Definitions:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY $rdx
  %1:gr64 = COPY $rsi
  %0:gr64 = COPY $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Live Variable Analysis:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY killed $rdx
  %1:gr64 = COPY killed $rsi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr killed %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr killed %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY killed %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY killed %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, killed %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 killed %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Machine Natural Loop Construction:
# Machine code for function runTest: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY killed $rdx
  %1:gr64 = COPY killed $rsi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr killed %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr killed %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY killed %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY killed %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, killed %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 killed %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Eliminate PHI nodes for register allocation:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY killed $rdx
  %1:gr64 = COPY killed $rsi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = nsw ADD32rr killed %11:gr32(tied-def 0), killed %13:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = nsw ADD32rr killed %14:gr32(tied-def 0), killed %15:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY killed %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY killed %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, killed %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = nsw ADD32ri8 killed %22:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Two-Address instruction pass:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rsi, $rdx
  %2:gr64 = COPY killed $rdx
  %1:gr64 = COPY killed $rsi
  %0:gr64 = COPY killed $rdi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed %1:gr64 :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed %2:gr64 :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed %3:gr32, killed %4:gr32, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %11:gr32 = MOVZX32rm8 killed %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  %13:gr32 = MOVZX32rm8 killed %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
  %14:gr32 = COPY killed %13:gr32  ==> insn has taint
  %14:gr32 = nsw ADD32rr %14:gr32(tied-def 0), killed %11:gr32, implicit-def dead $eflags  ==> insn has taint
  %15:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  %16:gr32 = COPY killed %15:gr32  ==> insn has taint
  %16:gr32 = nsw ADD32rr %16:gr32(tied-def 0), killed %14:gr32, implicit-def dead $eflags  ==> insn has taint
  %17:gr16 = COPY %16.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, killed %17:gr16 :: (store 2 into %ir.result)  ==> insn has taint
  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  %19:gr16 = COPY killed %18.sub_16bit:gr32  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, killed %19:gr16 :: (store 2 into %ir.carry)  ==> insn has taint
  %20:gr8 = COPY killed %16.sub_8bit:gr32  ==> insn has taint
  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  MOV8mr killed %21:gr64, 1, killed %10:gr64_nosp, 0, $noreg, killed %20:gr8 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  %22:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  %23:gr32 = COPY killed %22:gr32
  %23:gr32 = nsw ADD32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed %23:gr32 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  MOV8mr killed %7:gr64, 1, killed %8:gr64_nosp, 0, $noreg, killed %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Simple Register Coalescing:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rsi, $rdx
16B	  %2:gr64 = COPY $rdx
32B	  %1:gr64 = COPY $rsi
48B	  %0:gr64 = COPY $rdi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr %3:gr32, %4:gr32, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
304B	  %11:gr32 = MOVZX32rm8 %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
320B	  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  %14:gr32 = MOVZX32rm8 %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  %14:gr32 = nsw ADD32rr %14:gr32(tied-def 0), %11:gr32, implicit-def dead $eflags  ==> insn has taint
384B	  %16:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  %16:gr32 = nsw ADD32rr %16:gr32(tied-def 0), %14:gr32, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, %16.sub_16bit:gr32 :: (store 2 into %ir.result)  ==> insn has taint
464B	  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, %18.sub_16bit:gr32 :: (store 2 into %ir.carry)  ==> insn has taint
528B	  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
544B	  MOV8mr %21:gr64, 1, %10:gr64_nosp, 0, $noreg, %16.sub_8bit:gr32 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  %23:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  %23:gr32 = nsw ADD32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %23:gr32 :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
688B	  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
704B	  MOV8mr %7:gr64, 1, %8:gr64_nosp, 0, $noreg, %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Rename Disconnected Subregister Components:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rsi, $rdx
16B	  %2:gr64 = COPY $rdx
32B	  %1:gr64 = COPY $rsi
48B	  %0:gr64 = COPY $rdi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr %3:gr32, %4:gr32, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
304B	  %11:gr32 = MOVZX32rm8 %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
320B	  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  %14:gr32 = MOVZX32rm8 %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  %14:gr32 = nsw ADD32rr %14:gr32(tied-def 0), %11:gr32, implicit-def dead $eflags  ==> insn has taint
384B	  %16:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  %16:gr32 = nsw ADD32rr %16:gr32(tied-def 0), %14:gr32, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, %16.sub_16bit:gr32 :: (store 2 into %ir.result)  ==> insn has taint
464B	  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, %18.sub_16bit:gr32 :: (store 2 into %ir.carry)  ==> insn has taint
528B	  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
544B	  MOV8mr %21:gr64, 1, %10:gr64_nosp, 0, $noreg, %16.sub_8bit:gr32 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  %23:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  %23:gr32 = nsw ADD32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %23:gr32 :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
688B	  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
704B	  MOV8mr %7:gr64, 1, %8:gr64_nosp, 0, $noreg, %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Machine Instruction Scheduler:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rsi, $rdx
16B	  %2:gr64 = COPY $rdx
32B	  %1:gr64 = COPY $rsi
48B	  %0:gr64 = COPY $rdi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr %3:gr32, %4:gr32, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
304B	  %11:gr32 = MOVZX32rm8 %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
320B	  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  %14:gr32 = MOVZX32rm8 %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  %14:gr32 = nsw ADD32rr %14:gr32(tied-def 0), %11:gr32, implicit-def dead $eflags  ==> insn has taint
384B	  %16:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  %16:gr32 = nsw ADD32rr %16:gr32(tied-def 0), %14:gr32, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, %16.sub_16bit:gr32 :: (store 2 into %ir.result)  ==> insn has taint
464B	  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, %18.sub_16bit:gr32 :: (store 2 into %ir.carry)  ==> insn has taint
528B	  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
544B	  MOV8mr %21:gr64, 1, %10:gr64_nosp, 0, $noreg, %16.sub_8bit:gr32 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  %23:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  %23:gr32 = nsw ADD32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %23:gr32 :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
688B	  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
704B	  MOV8mr %7:gr64, 1, %8:gr64_nosp, 0, $noreg, %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Greedy Register Allocator:
# Machine code for function runTest: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi in %0, $rsi in %1, $rdx in %2

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rsi, $rdx
16B	  %2:gr64 = COPY $rdx
32B	  %1:gr64 = COPY $rsi
48B	  %0:gr64 = COPY $rdi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, %0:gr64 :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, %1:gr64 :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, %2:gr64 :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, %2:gr64 :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  %3:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  %4:gr32 = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr %3:gr32, %4:gr32, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  %9:gr64 = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  %10:gr64_nosp = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
304B	  %11:gr32 = MOVZX32rm8 %9:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx)
320B	  %12:gr64 = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  %14:gr32 = MOVZX32rm8 %12:gr64, 1, %10:gr64_nosp, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  %14:gr32 = nsw ADD32rr %14:gr32(tied-def 0), %11:gr32, implicit-def dead $eflags  ==> insn has taint
384B	  %16:gr32 = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  %16:gr32 = nsw ADD32rr %16:gr32(tied-def 0), %14:gr32, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, %16.sub_16bit:gr32 :: (store 2 into %ir.result)  ==> insn has taint
464B	  %18:gr32 = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, %18.sub_16bit:gr32 :: (store 2 into %ir.carry)  ==> insn has taint
528B	  %21:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
544B	  MOV8mr %21:gr64, 1, %10:gr64_nosp, 0, $noreg, %16.sub_8bit:gr32 :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  %23:gr32 = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  %23:gr32 = nsw ADD32ri8 %23:gr32(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, %23:gr32 :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  %6:gr8 = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  %7:gr64 = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)
688B	  %8:gr64_nosp = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
704B	  MOV8mr %7:gr64, 1, %8:gr64_nosp, 0, $noreg, %6:gr8 :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Virtual Register Rewriter:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rdx, $rsi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
304B	  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
320B	  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
384B	  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
464B	  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
528B	  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
544B	  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
688B	  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
704B	  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Stack Slot Coloring:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

0B	bb.0.entry:
	  successors: %bb.1(0x80000000); %bb.1(100.00%)
	  liveins: $rdi, $rdx, $rsi
64B	  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
80B	  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
96B	  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
112B	  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
128B	  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
144B	  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

160B	bb.1.for.cond:
	; predecessors: %bb.0, %bb.2
	  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

176B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
192B	  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
208B	  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
224B	  JGE_1 %bb.3, implicit killed $eflags
240B	  JMP_1 %bb.2

256B	bb.2.for.body:
	; predecessors: %bb.1
	  successors: %bb.1(0x80000000); %bb.1(100.00%)

272B	  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
288B	  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
304B	  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
320B	  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
336B	  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
368B	  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
384B	  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
416B	  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
448B	  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
464B	  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
496B	  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
528B	  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
544B	  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
560B	  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
592B	  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
608B	  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
624B	  JMP_1 %bb.1

640B	bb.3.for.end:
	; predecessors: %bb.1

656B	  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
672B	  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
688B	  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
704B	  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
720B	  RET 0

# End machine code for function runTest.

# After Machine Copy Propagation Pass:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Machine Loop Invariant Code Motion:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After X86 FP Stackifier:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After PostRA Machine Sink:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Shrink Wrapping analysis:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=8, align=8, at location [SP+8]
  fi#1: size=8, align=8, at location [SP+8]
  fi#2: size=8, align=8, at location [SP+8]
  fi#3: size=2, align=2, at location [SP+8]
  fi#4: size=4, align=4, at location [SP+8]
  fi#5: size=2, align=2, at location [SP+8]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  MOV64mr %stack.0.firstArray.addr, 1, $noreg, 0, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr %stack.1.secondArray.addr, 1, $noreg, 0, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr %stack.2.resultArray.addr, 1, $noreg, 0, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi %stack.3.carry, 1, $noreg, 0, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi %stack.4.i, 1, $noreg, 0, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm %stack.0.firstArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.1.secondArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr %stack.5.result, 1, $noreg, 0, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 %stack.5.result, 1, $noreg, 1, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr %stack.3.carry, 1, $noreg, 0, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm %stack.4.i, 1, $noreg, 0, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr %stack.4.i, 1, $noreg, 0, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm %stack.3.carry, 1, $noreg, 0, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm %stack.2.resultArray.addr, 1, $noreg, 0, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  RET 0

# End machine code for function runTest.

# After Prologue/Epilogue Insertion & Frame Finalization:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags
  JMP_1 %bb.2

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function runTest.

# After Control Flow Optimizer:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function runTest.

# After Tail Duplication:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function runTest.

# After Machine Copy Propagation Pass:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function runTest.

# After Post-RA pseudo instruction expansion pass:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RET 0

# End machine code for function runTest.

# After X86 pseudo instruction expansion pass:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Post RA top-down list latency scheduler:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Analyze Machine Code For Garbage Collection:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JGE_1 %bb.3, implicit killed $eflags

bb.2.for.body:
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Branch Probability Basic Block Placement:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Execution Dependency Fix:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After BreakFalseDeps:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Shadow Call Stack:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Indirect Branch Tracking:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 vzeroupper inserter:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Byte/Word Instruction Fixup:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Atom pad short functions:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 LEA Fixup:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Compressing EVEX instrs to VEX encoding when possible:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Discriminate Memory Operands:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Insert Cache Prefetches:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Contiguously Lay Out Funclets:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After StackMap Liveness Analysis:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Live DEBUG_VALUE analysis:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Insert fentry calls:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Insert XRay ops:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Implement the 'patchable-function' attribute:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 Retpoline Thunks:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After Check CFA info and insert CFI instructions if needed:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.1(0x80000000); %bb.1(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.1

bb.2.for.body (align 4):
; predecessors: %bb.1
  successors: %bb.1(0x80000000); %bb.1(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.1.for.cond:
; predecessors: %bb.0, %bb.2
  successors: %bb.2(0x7c000000), %bb.3(0x04000000); %bb.2(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.2, implicit $eflags

bb.3.for.end:
; predecessors: %bb.1

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  RETQ

# End machine code for function runTest.

# After X86 MBB to TASE Cartridge conversion pass.:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function runTest.

# After X86 TASE taint tracking instrumentation.:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi, $rdx, $rsi
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $r14 = LEA64r $rbp, 1, $noreg, -40, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  $r14 = LEA64r $rbp, 1, $noreg, -40, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -8, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  $r14 = LEA64r renamable $rax, 1, renamable $rcx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 4
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRDrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 3
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -10, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = MOVSSrm $r14, 1, $r14, 0, $noreg
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -9, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 2
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PINSRDrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 2
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  $r14 = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 0
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  $r14 = LEA64r $rbp, 1, $noreg, -8, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 0
  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  $r14 = LEA64r $rip, 1, $noreg, @numEntries, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  $r14 = LEA64r renamable $rcx, 1, renamable $rdx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 4
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg

bb.4.for.end:
; predecessors: %bb.3

  RETQ

# End machine code for function runTest.

# After X86 TASE cartridge prolog addition pass.:
# Machine code for function runTest: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#-1: size=8, align=16, fixed, at location [SP-8]
  fi#0: size=8, align=8, at location [SP-48]
  fi#1: size=8, align=8, at location [SP-40]
  fi#2: size=8, align=8, at location [SP-32]
  fi#3: size=2, align=2, at location [SP-10]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=2, align=2, at location [SP-18]
Function Live Ins: $rdi, $rsi, $rdx

bb.0.entry:
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $rdi, $rdx, $rsi
  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB6_0_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB6_0_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  frame-setup PUSH64r killed $rbp, implicit-def $rsp, implicit $rsp, pre-instr-symbol <mcsymbol .LBB6_0_CartridgeBody>
  CFI_INSTRUCTION def_cfa_offset 16
  CFI_INSTRUCTION offset $rbp, -16
  $rbp = frame-setup MOV64rr $rsp
  CFI_INSTRUCTION def_cfa_register $rbp
  $r14 = LEA64r $rbp, 1, $noreg, -40, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  MOV64mr $rbp, 1, $noreg, -40, $noreg, killed renamable $rdi :: (store 8 into %ir.firstArray.addr)  ==> insn has taint
  MOV64mr $rbp, 1, $noreg, -32, $noreg, killed renamable $rsi :: (store 8 into %ir.secondArray.addr)
  MOV64mr $rbp, 1, $noreg, -24, $noreg, renamable $rdx :: (store 8 into %ir.resultArray.addr)
  MOV64mr $rip, 1, $noreg, @resultPtr, $noreg, killed renamable $rdx :: (store 8 into @resultPtr)
  MOV16mi $rbp, 1, $noreg, -2, $noreg, 0 :: (store 2 into %ir.carry)
  MOV32mi $rbp, 1, $noreg, -8, $noreg, 0 :: (store 4 into %ir.i)
  JMP_1 %bb.2, post-instr-symbol <mcsymbol .LBB6_0_CartridgeEnd>

bb.1.for.body (align 4):
; predecessors: %bb.2
  successors: %bb.2(0x80000000); %bb.2(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB6_1_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB6_1_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -40, $noreg, pre-instr-symbol <mcsymbol .LBB6_1_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rax = MOV64rm $rbp, 1, $noreg, -40, $noreg :: (dereferenceable load 8 from %ir.firstArray.addr)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -8, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $rcx = MOVSX64rm32 $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  $r14 = LEA64r renamable $rax, 1, renamable $rcx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 4
  renamable $eax = MOVZX32rm8 killed renamable $rax, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx)  ==> insn has taint
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -32, $noreg :: (dereferenceable load 8 from %ir.secondArray.addr)
  renamable $edx = MOVZX32rm8 killed renamable $rdx, 1, renamable $rcx, 0, $noreg :: (load 1 from %ir.arrayidx3)
  renamable $edx = nsw ADD32rr killed renamable $edx(tied-def 0), killed renamable $eax, implicit-def dead $eflags  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRDrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 3
  renamable $eax = MOVZX32rm16 $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 2 from %ir.carry)  ==> insn has taint
  renamable $eax = nsw ADD32rr killed renamable $eax(tied-def 0), killed renamable $edx, implicit-def dead $eflags  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -10, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = MOVSSrm $r14, 1, $r14, 0, $noreg
  MOV16mr $rbp, 1, $noreg, -10, $noreg, renamable $ax :: (store 2 into %ir.result)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -9, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 2
  renamable $edx = MOVZX32rm8 $rbp, 1, $noreg, -9, $noreg :: (dereferenceable load 1 from %ir.result + 1)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PINSRDrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 2
  MOV16mr $rbp, 1, $noreg, -2, $noreg, renamable $dx, implicit killed $edx :: (store 2 into %ir.carry)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rdx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  $r14 = LEA64r renamable $rdx, 1, renamable $rcx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 0
  MOV8mr killed renamable $rdx, 1, killed renamable $rcx, 0, $noreg, renamable $al, implicit killed $eax :: (store 1 into %ir.arrayidx15)  ==> insn has taint
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)
  renamable $eax = nsw ADD32ri8 killed renamable $eax(tied-def 0), 1, implicit-def dead $eflags
  MOV32mr $rbp, 1, $noreg, -8, $noreg, killed renamable $eax, post-instr-symbol <mcsymbol .LBB6_1_CartridgeEnd> :: (store 4 into %ir.i)

bb.2.for.cond:
; predecessors: %bb.0, %bb.1
  successors: %bb.1(0x7c000000), %bb.3(0x04000000); %bb.1(96.88%), %bb.3(3.12%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB6_2_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB6_2_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -8, $noreg, pre-instr-symbol <mcsymbol .LBB6_2_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $eax = MOV32rm $rbp, 1, $noreg, -8, $noreg :: (dereferenceable load 4 from %ir.i)  ==> insn has taint
  renamable $ecx = MOV32rm $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)
  CMP32rr killed renamable $eax, killed renamable $ecx, implicit-def $eflags
  JL_1 %bb.1, implicit $eflags, post-instr-symbol <mcsymbol .LBB6_2_CartridgeEnd>

bb.3.for.end:
; predecessors: %bb.2
  successors: %bb.4(0x80000000); %bb.4(100.00%)

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB6_3_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB6_3_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  $r14 = LEA64r $rbp, 1, $noreg, -2, $noreg, pre-instr-symbol <mcsymbol .LBB6_3_CartridgeBody>
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 0
  renamable $al = MOV8rm $rbp, 1, $noreg, -2, $noreg :: (dereferenceable load 1 from %ir.carry, align 2)  ==> insn has taint
  $r14 = LEA64r $rbp, 1, $noreg, -24, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = PCMPEQWrr $xmm15(tied-def 0), $xmm13
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  $xmm15 = VPCMPEQWrm $xmm13, $r14, 1, $r14, 0, $noreg
  $xmm14 = PORrr $xmm14(tied-def 0), $xmm15
  renamable $rcx = MOV64rm $rbp, 1, $noreg, -24, $noreg :: (dereferenceable load 8 from %ir.resultArray.addr)  ==> insn has taint
  $r14 = LEA64r $rip, 1, $noreg, @numEntries, $noreg
  $r15d = MOV32ri 1
  $r14 = SHRX64rr $r14, $r15
  $xmm15 = MOVSDrm $r14, 1, $r14, 0, $noreg
  renamable $rdx = MOVSX64rm32 $rip, 1, $noreg, @numEntries, $noreg :: (dereferenceable load 4 from @numEntries)  ==> insn has taint
  $r14 = LEA64r renamable $rcx, 1, renamable $rdx, 0, $noreg
  $r14 = SHR64r1 $r14(tied-def 0), implicit-def $eflags
  $xmm15 = PINSRWrm $xmm15(tied-def 0), $r14, 1, $r14, 0, $noreg, 4
  MOV8mr killed renamable $rcx, 1, killed renamable $rdx, 0, $noreg, killed renamable $al :: (store 1 into %ir.arrayidx18)  ==> insn has taint
  $rbp = frame-destroy POP64r implicit-def $rsp, implicit $rsp
  CFI_INSTRUCTION def_cfa $rsp, 8
  $r14 = MOV64rm $rsp, 1, $noreg, 0, $noreg, post-instr-symbol <mcsymbol .LBB6_3_CartridgeEnd>

bb.4.for.end:
; predecessors: %bb.3

  $r15 = LEA64r $rip, 1, $noreg, <mcsymbol .LBB6_4_CartridgeBody>, $noreg, pre-instr-symbol <mcsymbol .LBB6_4_CartridgeHead>
  TASE_JMP_4 &sb_reopen
  RETQ pre-instr-symbol <mcsymbol .LBB6_4_CartridgeBody> post-instr-symbol <mcsymbol .LBB6_4_CartridgeEnd>

# End machine code for function runTest.

